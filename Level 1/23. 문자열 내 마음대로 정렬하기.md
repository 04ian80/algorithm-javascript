## 문제설명

문자열로 구성된 리스트 strings와, 정수 n이 주어졌을 때, 각 문자열의 인덱스 n번째 글자를 기준으로 오름차순 정렬하려 합니다. 예를 들어 strings가 ["sun", "bed", "car"]이고 n이 1이면 각 단어의 인덱스 1의 문자 "u", "e", "a"로 strings를 정렬합니다.

**제한사항**

- strings는 길이 1 이상, 50이하인 배열입니다.
- strings의 원소는 소문자 알파벳으로 이루어져 있습니다.
- strings의 원소는 길이 1 이상, 100이하인 문자열입니다.
- 모든 strings의 원소의 길이는 n보다 큽니다.
- 인덱스 1의 문자가 같은 문자열이 여럿 일 경우, 사전순으로 앞선 문자열이 앞쪽에 위치합니다.

**입출력 예**

| strings                 | n   | return                  |
| ----------------------- | --- | ----------------------- |
| ["sun", "bed", "car"]   | 1   | ["car", "bed", "sun"]   |
| ["abce", "abcd", "cdx"] | 2   | ["abcd", "abce", "cdx"] |

**입출력 예 설명**

- 입출력 예 1
  "sun", "bed", "car"의 1번째 인덱스 값은 각각 "u", "e", "a" 입니다. 이를 기준으로 strings를 정렬하면 ["car", "bed", "sun"] 입니다.

- 입출력 예 2
  "abce"와 "abcd", "cdx"의 2번째 인덱스 값은 "c", "c", "x"입니다. 따라서 정렬 후에는 "cdx"가 가장 뒤에 위치합니다. "abce"와 "abcd"는 사전순으로 정렬하면 "abcd"가 우선하므로, 답은 ["abcd", "abce", "cdx"] 입니다.

## 풀이

```js
function solution(strings, n) {
  strings.sort((a, b) => {
    if (a[n] > b[n]) {
      return 1;
    }
    if (a[n] === b[n] && a > b) {
      return 1;
    }
    return -1;
  });
  return strings;
}
// 제일 오래 걸린 케이스통과(0.14ms, 33.4MB)
// 제일 빠른 케이스(0.05ms, 33.4MB)
```

### 설명

- 설명: 문자열로 이루어진 배열과 인덱스 n이 주어질 때 배열안에 문자열의 n번째 인덱스를 기준으로 정렬
- n번째 인덱스를 기준으로 했을 때 큰순으로 정렬
- n번째 인덱스들이 같은 알파벳이라면 문자 전체를 비교하여 정렬

## 다른 사람의 풀이 1

```js
function solution(strings, n) {
  // strings 배열
  // n 번째 문자열 비교
  return strings.sort((s1, s2) =>
    s1[n] === s2[n] ? s1.localeCompare(s2) : s1[n].localeCompare(s2[n])
  );
}
// 제일 오래 걸린 케이스(556.37ms, 36MB)
// 제일 빠른 케이스(8.69ms, 36.1MB)
```

### 설명

- localeCompare: 문자열이 정렬순으로 지정된 문자열 앞 혹은 뒤에 오는지 또는 동일한 문자열인지 나타내는 수치를 반환
- n번째 인덱스의 알파벳이 같으면 문자열 전체적으로 정렬 비교.
- 같지 않으면(크거나 작으면) 문자열의 n번째 인덱스끼리 비교
