## 문제설명

문자열 s는 한 개 이상의 단어로 구성되어 있습니다. 각 단어는 하나 이상의 공백문자로 구분되어 있습니다. 각 단어의 짝수번째 알파벳은 대문자로, 홀수번째 알파벳은 소문자로 바꾼 문자열을 리턴하는 함수, solution을 완성하세요.

**제한사항**

- 문자열 전체의 짝/홀수 인덱스가 아니라, 단어(공백을 기준)별로 짝/홀수 인덱스를 판단해야합니다.
- 첫 번째 글자는 0번째 인덱스로 보아 짝수번째 알파벳으로 처리해야 합니다.

**입출력 예**

| s                 | return            |
| ----------------- | ----------------- |
| "try hello world" | "TrY HeLlO WoRlD" |

## 풀이

```js
function solution(s) {
  let answer = '';
  let count = 0;

  for (let i = 0; i < s.length; i++) {
    if (s[i] === ' ') {
      answer += ' ';
      count = 0;
      continue;
    }
    answer += count % 2 === 0 ? s[i].toUpperCase() : s[i].toLowerCase();
    count++;
  }
  return answer;
}
// 제일 오래 걸린 케이스(0.23ms, 33.4MB)
// 제일 빠른 케이스(0.05ms, 33.5MB)
```

### 설명

- 문자열을 돌면서 각 단어의 짝수번째는 대문자로, 홀수번째는 소문자로 바꾸어 또다른 answer 문자열에 집어넣는다.
- 만약 공백을 마주친다면 빈문자열을 answer 문자열에 집어넣는다.
- 문제는 문자열 전체에서 짝수홀수를 세는것이 아닌 "단어별로" 세는 것이기 때문에 반복문의 i로 세면 안되고 count를 새로 만들어서 단어의 인덱스를 세준다음에 단어가 끝나면 초기화해주는 식으로 한다.

---

## 다른 사람의 풀이

```js
function solution(s) {
  return s.toUpperCase().replace(/(\w)(\w)/g, (a) => {
    return a[0].toUpperCase() + a[1].toLowerCase();
  });
}
// 제일 오래 걸린 케이스(0.23ms, 33.4MB)
// 제일 빠른 케이스(0.11ms, 33.4MB)
```

### 설명

- 문자열을 전부 대문자로 만든 다음, 정규식을 사용하여 대소문자로 바꿔준다.
- (\w)(\w)는 연속된 두문자를 비교하는건데 replace 함수의 두번째로 들어가는 콜백이 이 두 문자.
- 예를 들어 try이면 t와 r을 전달. 그 다음으로 y를 전달해야 하는데 y뒤에는 아무것도 없거나 공백이기 때문에 전달할 수 없음.
- 그렇기 때문에 처음에 문자열을 전부 대문자로 치환.
- 단어가 짝수면 둘을 전달하여 첫번째 알파벳은 대문자로 바꾸고 두번째 알파벳은 소문자로 바꾸는 작업을 할 수 있는데, 단어가 홀수면 맨 뒤 알파벳은 그걸 못하기 때문에 처음에 모두 대문자로 바꿔주는 것.

```js
function solution(s) {
  return s
    .split(' ')
    .map((i) =>
      i
        .split('')
        .map((j, key) => (key % 2 === 0 ? j.toUpperCase() : j.toLowerCase()))
        .join('')
    )
    .join(' ');
}
// 제일 오래 걸린 케이스(0.31ms, 33.5MB)
// 제일 빠른 케이스(0.06ms, 33.6MB)
```

### 설명

- 공백을 기준으로 문자열을 단어별로 나누어 배열로만들어준다.
- 단어를 돌면서 또 알파벳을 배열로 나눠준다.
- 알파벳 배열을 돌면서 알파벳의 인덱스가 짝수면 대문자로, 홀수면 소문자로 바꿔준 뒤 다시 문자열로 합쳐준다.
