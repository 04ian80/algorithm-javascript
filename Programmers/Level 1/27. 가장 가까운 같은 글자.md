## 문제설명

문자열 `s`가 주어졌을 때, `s`의 각 위치마다 자신보다 앞에 나왔으면서, 자신과 가장 가까운 곳에 있는 같은 글자가 어디 있는지 알고 싶습니다.
예를 들어, `s` = "banana"라고 할 때, 각 글자들을 왼쪽부터 오른쪽으로 읽어 나가면서 다음과 같이 진행할 수 있습니다.

b는 처음 나왔기 때문에 자신의 앞에 같은 글자가 없습니다. 이는 -1로 표현합니다.
a는 처음 나왔기 때문에 자신의 앞에 같은 글자가 없습니다. 이는 -1로 표현합니다.
n은 처음 나왔기 때문에 자신의 앞에 같은 글자가 없습니다. 이는 -1로 표현합니다.
a는 자신보다 두 칸 앞에 a가 있습니다. 이는 2로 표현합니다.
n도 자신보다 두 칸 앞에 n이 있습니다. 이는 2로 표현합니다.
a는 자신보다 두 칸, 네 칸 앞에 a가 있습니다. 이 중 가까운 것은 두 칸 앞이고, 이는 2로 표현합니다.
따라서 최종 결과물은 [-1, -1, -1, 2, 2, 2]가 됩니다.

문자열 `s`가 주어질 때, 위와 같이 정의된 연산을 수행하는 함수 solution을 완성해주세요.

**제한사항**

- 1 ≤ s의 길이 ≤ 10,000
  - s은 영어 소문자로만 이루어져 있습니다.

**입출력 예**

| s        | result                  |
| -------- | ----------------------- |
| "banana" | [-1, -1, -1, 2, 2, 2]   |
| "foobar" | [-1, -1, 1, -1, -1, -1] |

## 풀이

```js
function solution(s) {
  let answer = [];

  for (let i = 0; i < s.length; i++) {
    const existNum = s.substring(0, i).lastIndexOf(s[i]);
    answer.push(existNum !== -1 ? i - existNum : existNum);
  }

  return answer;
}

// 제일 오래 걸린 케이스(28.15ms, 37.7MB)
// 제일 빠른 케이스(0.04ms, 33.4MB)
```

### 설명

- substring으로 문자열을 0번째 인덱스부터 차례대로 s의 길이만큼 잘라보면서 i번째 문자의 앞문자열에 i번째 문자와 같은 문자가 있는지 확인한다.
- 문자열에 i번째 문자와 같은 문자가 있으면 i번째 문자를 제외하고 제일 마지막에 있는 문자를 뽑아낸다.
- 만약 앞문자열에 i번째와 같은 문자가 있으면 i에서 lastIndex의 index를 빼주고, 같은 문자가 없으면 -1를 반환한다.

## 다른 사람의 풀이

```js
function solution(s) {
  const hash = {};

  return [...s].map((v, i) => {
    let result = hash[v] !== undefined ? i - hash[v] : -1;
    hash[v] = i;
    return result;
  });
}

// 제일 오래 걸린 케이스(2.05ms, 36.5MB)
// 제일 빠른 케이스(0.06ms, 33.4MB)
```

### 설명

- map을 사용하여 배열을 반환한다.
- hash라는 객체에 한번도 등록되지 않은 문자면 -1을 반환하고, 등록되어있다면 i - hash[v]를 하여 인덱스를 반환한다.
